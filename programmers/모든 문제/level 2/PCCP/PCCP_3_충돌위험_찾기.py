# 프로그래머스 문제 풀이 - [PCCP 기출문제] 3번 / 충돌위험 찾기 (340211)

## 문제 정보
# **문제 이름**: [PCCP 기출문제] 3번 / 충돌위험 찾기
# **문제 번호**: 340211
# **문제 레벨**: 2
# **링크**: [링크](https://programmers.co.kr/learn/courses/30/lessons/340211)
# **풀이 날짜** : 2024-11-18

## 문제 
# 문제 설명 :
# 어떤 물류 센터는 로봇을 이용한 자동 운송 시스템을 운영합니다. 운송 시스템이 작동하는 규칙은 다음과 같습니다.
# 물류 센터에는 (r, c)와 같이 2차원 좌표로 나타낼 수 있는 n개의 포인트가 존재합니다. 각 포인트는 1~n까지의 서로 다른 번호를 가집니다.
# 로봇마다 정해진 운송 경로가 존재합니다. 운송 경로는 m개의 포인트로 구성되고 로봇은 첫 포인트에서 시작해 할당된 포인트를 순서대로 방문합니다.
# 운송 시스템에 사용되는 로봇은 x대이고, 모든 로봇은 0초에 동시에 출발합니다. 로봇은 1초마다 r 좌표와 c 좌표 중 하나가 1만큼 감소하거나 증가한 좌표로 이동할 수 있습니다.
# 다음 포인트로 이동할 때는 항상 최단 경로로 이동하며 최단 경로가 여러 가지일 경우, r 좌표가 변하는 이동을 c 좌표가 변하는 이동보다 먼저 합니다.
# 마지막 포인트에 도착한 로봇은 운송을 마치고 물류 센터를 벗어납니다. 로봇이 물류 센터를 벗어나는 경로는 고려하지 않습니다.
#
# 이동 중 같은 좌표에 로봇이 2대 이상 모인다면 충돌할 가능성이 있는 위험 상황으로 판단합니다. 
# 관리자인 당신은 현재 설정대로 로봇이 움직일 때 위험한 상황이 총 몇 번 일어나는지 알고 싶습니다. 만약 어떤 시간에 여러 좌표에서 위험 상황이 발생한다면 그 횟수를 모두 더합니다.

## 코드
def solution(points, routes):
    answer = 0
    dic, f = {}, {}
    for i, r in enumerate(routes):
        if r[0] in f :
            if f[r[0]] == 1: answer += 1
            f[r[0]] += 1
        else : f[r[0]] = 1
        dic[i] = [points[r[0]-1], r[1:] ]

    while True :
        pos = {}
        for k, d in dic.items():
            x, y = d[0]
            px, py = points[d[1][0]-1]
            if x==px and y==py :
                if len(d[1])==1:
                    continue
                else :
                    dic[k][1] = d[1][1:]
                    px, py = points[d[1][0]-1]
            
            if px != x : x += (px - x)//abs(px - x)
            else : y += (py - y)//abs(py - y)
            dic[k][0] = [x, y]

            p = x * 1000 + y
            if p in pos :
                if pos[p] == 1 :
                    answer += 1
                    
                pos[p] += 1
            else : pos[p] = 1
        if len(pos) == 0 : break
    return answer
